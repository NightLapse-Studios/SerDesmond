[{"title":"Development","type":0,"sectionRef":"#","url":"/SerDesmond/docs/ProjectStructure","content":"Development Project structure is simple. Roblox Studio is used as a dev environment. Development files are in src/ReplicatedFirst/Modules, including test files, the benchmark script, project dependencies (Squash for benchmarking), and the library itself. A config file is at src/ReplicatedFirst/Config.luau. It has a Benchmarks and Testing flag that are used to toggle the associated features when you run the project. The file inherits from LazyModule's config file as we use that to run our scripts/tests at runtime. Knowledge of LazyModules is not necessary, it simply works.","keywords":""},{"title":"Performance","type":0,"sectionRef":"#","url":"/SerDesmond/docs/Performance","content":"","keywords":""},{"title":"Compilation​","type":1,"pageTitle":"Performance","url":"/SerDesmond/docs/Performance#compilation","content":"Obviously SerDesmond is much slower to construct than Squash due to having a compilation from string stage. It will never be as fast as other libraries in this regard, it will always be orders of magnitude slower (currently ~1.5 to 2.5 orders of magnitude slower). However, it can compile about 1.2-2.1mB/s depending on the structure. Larger structures tend to have higher throughput. I can compile a simple map 41k times per second with 1.2 mB/s throughput while the ManyFieldsCompTest compiles 14k times per second with a throughput of ~2.1 mB/s on my machine. Whitespace can inflate perceived throughput values since they do not entail any work in the compilation stage. It seems that it's already the case that only truly massive structures need to worry about compilation time, which should generally be done only once on application startup to begin with. "},{"title":"SerDes​","type":1,"pageTitle":"Performance","url":"/SerDesmond/docs/Performance#serdes","content":"SerDes performance is about the same as any other buffer SerDes library since we still compile down to the same constructs as them. We don't do buffer reallocations though, so in principle we will tend to be faster. Faster SerDes is a goal of this project. Due to lack of time in the oven, desmond may be slower in some scenarios or may be missing byte-saving strategies. E.G. writing an 18 element array is marginally faster than Squash, meanwhile writing to a struct with 3 fields is marginally slower. Large structures should expect overall better performance due to lack of buffer reallocations. "},{"title":"Getting started","type":0,"sectionRef":"#","url":"/SerDesmond/docs/intro","content":"Getting started Getting started is as easy as calling SerDesmond.Compile on a string: local SerDesmond = require(&quot;../SerDesmond&quot;) local ser, des = SerDesmond.Compile([[array(i8, f64)]]) local buf = ser({-1, 3.14}) local original = des(buf) Constructs listed on the top-level of the compiled string will each correspond to an argument in the resulting serializer, as well as causing the deserializer to output a tuple local ser, des = SerDesmond.Compile([[i8, array(i8)]]) local buf = ser(1, {2}) local a1, a2 = des(buf) -- a1 == 1, a2 == {[1] = 2} (WIP): Errors in the input can be annotated by passing true as the 2nd argument to CompileAt the moment the output can be sloppy if there are multiple errors on one line SerDesmond.Compile(&quot;array(i88, i8)&quot;, true) -- array(i88, i8) -- ^^^ -- Error: Unrecognized type identifier i88 ","keywords":""},{"title":"Table","type":0,"sectionRef":"#","url":"/SerDesmond/api/Table","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#functions","content":" "},{"title":"append​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#append","content":"&lt;/&gt; Table.append( target: table,-- Table to append to source: table-- Table read from ) → table-- parameter table Concats target with source.  "},{"title":"merge​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#merge","content":"&lt;/&gt; Table.merge( orig: table,-- Original table new: table-- Result ) → table Shallow merges two tables without modifying either.  "},{"title":"reverse​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#reverse","content":"&lt;/&gt; Table.reverse( orig: table-- Original table ) → table Reverses the list and returns the reversed copy  "},{"title":"values​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#values","content":"&lt;/&gt; Table.values( source: table-- Table source to extract values from ) → table-- A list with all the values the table has Returns a list of all of the values that a table has.  "},{"title":"keys​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#keys","content":"&lt;/&gt; Table.keys( source: table-- Table source to extract keys from ) → table-- A list with all the keys the table has Returns a list of all of the keys that a table has. (In order of pairs)  "},{"title":"mergeLists​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#mergeLists","content":"&lt;/&gt; Table.mergeLists( orig: table,-- Original table new: table-- Result ) → table Shallow merges two lists without modifying either.  "},{"title":"swapKeyValue​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#swapKeyValue","content":"&lt;/&gt; Table.swapKeyValue( orig: table-- Original table ) → table Swaps keys with values, overwriting additional values if duplicated.  "},{"title":"toList​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#toList","content":"&lt;/&gt; Table.toList( _table: table-- Table to convert to a list ) → table Converts a table to a list.  "},{"title":"count​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#count","content":"&lt;/&gt; Table.count( _table: table-- Table to count ) → number-- count Counts the number of items in _table. Useful since __len on table in Lua 5.2 returns just the array length.  "},{"title":"Table.copy​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#Table.copy","content":"&lt;/&gt; Table.Table.copy( target: table-- Table to copy ) → table-- Result Shallow copies a table from target into a new table  "},{"title":"deepCopy​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#deepCopy","content":"&lt;/&gt; Table.deepCopy( target: table,-- Table to deep copy _context: table?-- Context to deepCopy the value in ) → table-- Result Deep copies a table including metatables  "},{"title":"deepOverwrite​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#deepOverwrite","content":"&lt;/&gt; Table.deepOverwrite( target: table,-- Target table source: table-- Table to read from ) → table-- target Overwrites a table's value  "},{"title":"getIndex​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#getIndex","content":"&lt;/&gt; Table.getIndex( haystack: table,-- To search in needle: Valuetosearchfor ) → ( Theindexofthevalue,iffound, nil-- if not found ) Gets an index by value, returning nil if no index is found.  "},{"title":"stringify​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#stringify","content":"&lt;/&gt; Table.stringify( _table: table,-- Table to stringify indent: number?,-- Indent level output: string?-- Output string, used recursively ) → string-- The table in string form Recursively prints the table. Does not handle recursive tables.  "},{"title":"contains​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#contains","content":"&lt;/&gt; Table.contains( _table: table,-- To search in for value value: any-- Value to search for ) → boolean-- true if within, false otherwise Returns whether value is within table  "},{"title":"overwrite​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#overwrite","content":"&lt;/&gt; Table.overwrite( target: table,-- Table to overwite source: table-- Source table to read from ) → table-- target Overwrites an existing table with the source values.  "},{"title":"deepEquivalent​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#deepEquivalent","content":"&lt;/&gt; Table.deepEquivalent( target: table,-- Table to check source: table-- Other table to check ) → boolean Deep equivalent comparison of a table assuming keys are indexable in the same way.  "},{"title":"take​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#take","content":"&lt;/&gt; Table.take( source: table,-- Source table to retrieve values from count: number-- Number of entries to take ) → table-- List with the entries retrieved Takes count entries from the table. If the table does not have that many entries, will return up to the number the table has to provide.  "},{"title":"readonly​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#readonly","content":"&lt;/&gt; Table.readonly( target: table-- Table to error on indexing ) → table-- The same table, with the metatable set to readonly Sets a metatable on a table such that it errors when indexing a nil value  "},{"title":"deepReadonly​","type":1,"pageTitle":"Table","url":"/SerDesmond/api/Table#deepReadonly","content":"&lt;/&gt; Table.deepReadonly( target: table-- Table to error on indexing ) → table-- The same table Recursively sets the table as ReadOnly "},{"title":"Usage","type":0,"sectionRef":"#","url":"/SerDesmond/docs/Syntax","content":"","keywords":""},{"title":"General​","type":1,"pageTitle":"Usage","url":"/SerDesmond/docs/Syntax#general","content":"SerDesmond generally takes in a list of type literals and then their parameters if there are any. Each entry in the top-level of the string corresponds to an argument in the serialize function, and a result from the deserialize function. Comma separators are optional but preferred. Keywords are all lowercase, even for Vector3 which should be declared as vector3(...). Aliases may be added in the future. local ser, _ = SerDesmond.Compile(&quot;i8, f64&quot;) local buf = ser(1, 3.14)  Some constructs associate one type with another using a &quot;binding&quot;, like so (the colon separator is not optional!): SerDesmond.Compile([[ struct(&quot;field_1&quot;: i8) ]])  Nested types are allowed where appropriate: SerDesmond.Compile([[ array( struct(&quot;field_1&quot;: i8), struct(&quot;field_1&quot;: i8), ) ]])  "},{"title":"Constructs​","type":1,"pageTitle":"Usage","url":"/SerDesmond/docs/Syntax#constructs","content":""},{"title":"Type literals​","type":1,"pageTitle":"Usage","url":"/SerDesmond/docs/Syntax#type-literals","content":"Type literals correspond to the associated buffer primitives: SerDesmond.Compile([[ i8, i16, i32, u8, u16, u32, f32, f64 ]])  "},{"title":"Number literals​","type":1,"pageTitle":"Usage","url":"/SerDesmond/docs/Syntax#number-literals","content":"Number literals function like a type literals except their stored size is base on the number supplied. You still need to supply the value as an argument for performance reasons, and the supplied number can override the literal (also for performance reasons); there is NO benefit to using number literals like that intentionally, use a type literal instead. local ser, des = SerDesmond.Compile([[ array(1, 2) ]]) local result = des(ser(1, 2)) -- result == { [1] = 1, [2] = 2}  "},{"title":"String literals​","type":1,"pageTitle":"Usage","url":"/SerDesmond/docs/Syntax#string-literals","content":"String literals function like number literals, however, the value passed in is ignored and the compiled value is used. The treatment of arguments may be made consistent between number/string literals in the future. The behavior of ignoring the argument is not intended to be leveraged. local ser, des = SerDesmond.Compile([[ &quot;test&quot; ]]) local result = des(ser(1)) -- result == &quot;test&quot;  "},{"title":"Strings​","type":1,"pageTitle":"Usage","url":"/SerDesmond/docs/Syntax#strings","content":"Strings are just like string literals except any string can take its value. local ser, des = SerDesmond.Compile([[ array(string, string) ]]) local result = des(ser({&quot;one&quot;, &quot;three&quot;})) -- result == {&quot;one&quot;, &quot;three&quot;}  "},{"title":"Arrays​","type":1,"pageTitle":"Usage","url":"/SerDesmond/docs/Syntax#arrays","content":"Arrays are a fixed-length ordered list of constructs. You cannot use less or more than the list of supplied constructs. local ser, des = SerDesmond.Compile([[ array( array(&quot;Yep&quot;, i8), array(f32, f32) ) ]]) local result = des(ser({ { &quot;Yep&quot;, 1 }, { 3.14, -3.14 } }))  "},{"title":"Periodic arrays​","type":1,"pageTitle":"Usage","url":"/SerDesmond/docs/Syntax#periodic-arrays","content":"Sometimes you just have a list of things that you want to chuck in a single array... over and over. You can describe that with periodic arrays, who's contents will be just like an array but it can repeat any number of times. local ser, des = SerDesmond.Compile([[ periodic_array( string, i8 ) ]]) local result = des(ser({ &quot;thing1&quot;, 1 &quot;thing2&quot;, 2 })) -- result == { -- [1] = &quot;thing1&quot;, -- [2] = 1, -- [3] = &quot;thing2, -- [4] = 2, -- }  "},{"title":"Enums​","type":1,"pageTitle":"Usage","url":"/SerDesmond/docs/Syntax#enums","content":"An enum is a list of strings that will be stored as numbers instead. You can use each string any number of times. The deserialized order is not equivalent to the order they are passed in. local ser, des = SerDesmond.Compile([[ enum( &quot;test1&quot;, &quot;test2, &quot;test3 ) ]]) local buf = ser({&quot;test1&quot;, &quot;test1&quot;, &quot;test3&quot;}) -- buf len == 3, contains 0x1, 0x1, 0x3 in any order local result = des(buf) -- result == {&quot;test1&quot;, &quot;test1&quot;, &quot;test3&quot;} -- but in any order!  "},{"title":"Maps​","type":1,"pageTitle":"Usage","url":"/SerDesmond/docs/Syntax#maps","content":"Describes a table with an indexer of one type and a value of another type local ser, des = SerDesmond.Compile([[ map( string: i8 ) ]]) local result = des(ser( {thing1 = 1, thing2 = 2} )) -- result == {thing1 = 1, thing2 = 2}  "},{"title":"Structs​","type":1,"pageTitle":"Usage","url":"/SerDesmond/docs/Syntax#structs","content":"Maps indexers that are type literals to a construct. Can use both string and number literals as indexers. local ser, des = SerDesmond.Compile([[ struct( &quot;thing1&quot;: i8, &quot;thing2&quot;: f64 ) ]]) local result = des(ser( {thing1 = 1, thing2 = 3.14} ))  "},{"title":"Vector3​","type":1,"pageTitle":"Usage","url":"/SerDesmond/docs/Syntax#vector3","content":"A simple Vector3 :~) Unlike most libraries each axis can be restricted to its own primitive. local ser, des = SerDesmond.Compile([[ vector3(i8, i32, i8)]])  "},{"title":"Comments​","type":1,"pageTitle":"Usage","url":"/SerDesmond/docs/Syntax#comments","content":"We support comments with the # symbol. local ser, des = SerDesmond.Compile([[ # This is my fancy thing struct # It is so cool ( &quot;thing1&quot;: # I just love it f64 ) ]])  "}]