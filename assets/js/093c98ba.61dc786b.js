"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[32],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>g});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=r.createContext({}),u=function(e){var t=r.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(o.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,o=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=u(n),m=a,g=p["".concat(o,".").concat(m)]||p[m]||d[m]||l;return n?r.createElement(g,s(s({ref:t},c),{},{components:n})):r.createElement(g,s({ref:t},c))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,s=new Array(l);s[0]=m;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i[p]="string"==typeof e?e:a,s[1]=i;for(var u=2;u<l;u++)s[u]=n[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},46771:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>u});var r=n(87462),a=(n(67294),n(3905));const l={sidebar_position:2},s="Usage",i={unversionedId:"Syntax",id:"Syntax",title:"Usage",description:"General",source:"@site/docs/Syntax.md",sourceDirName:".",slug:"/Syntax",permalink:"/SerDesmond/docs/Syntax",draft:!1,editUrl:"https://github.com/NightLapse-Studios/SerDesmond/edit/master/docs/Syntax.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"defaultSidebar",previous:{title:"Getting started",permalink:"/SerDesmond/docs/intro"},next:{title:"Performance",permalink:"/SerDesmond/docs/Performance"}},o={},u=[{value:"General",id:"general",level:2},{value:"Constructs",id:"constructs",level:2},{value:"Type literals",id:"type-literals",level:3},{value:"Number literals",id:"number-literals",level:3},{value:"String literals",id:"string-literals",level:3},{value:"Strings",id:"strings",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Periodic arrays",id:"periodic-arrays",level:3},{value:"Enums",id:"enums",level:3},{value:"Maps",id:"maps",level:3},{value:"Structs",id:"structs",level:3},{value:"Vector3",id:"vector3",level:3},{value:"Comments",id:"comments",level:3}],c={toc:u},p="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"usage"},"Usage"),(0,a.kt)("h2",{id:"general"},"General"),(0,a.kt)("p",null,"SerDesmond generally takes in a list of type literals and then their parameters if there are any. Each entry in the top-level of the string corresponds to an argument in the serialize function, and a result from the deserialize function. Comma separators are optional but preferred."),(0,a.kt)("p",null,"Keywords are all lowercase, even for Vector3 which should be declared as ",(0,a.kt)("inlineCode",{parentName:"p"},"vector3(...)"),". Aliases ",(0,a.kt)("em",{parentName:"p"},"may")," be added in the future."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local ser, _ = SerDesmond.Compile("i8, f64")\n\nlocal buf = ser(1, 3.14)\n')),(0,a.kt)("p",null,'Some constructs associate one type with another using a "binding", like so (the colon separator is not optional!):'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'SerDesmond.Compile([[ struct("field_1": i8) ]])\n')),(0,a.kt)("p",null,"Nested types are allowed where appropriate:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'SerDesmond.Compile([[\n    array(\n        struct("field_1": i8),\n        struct("field_1": i8),\n    )\n]])\n')),(0,a.kt)("h2",{id:"constructs"},"Constructs"),(0,a.kt)("h3",{id:"type-literals"},"Type literals"),(0,a.kt)("p",null,"Type literals correspond to the associated buffer primitives:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"SerDesmond.Compile([[\n    i8,\n    i16,\n    i32,\n    u8,\n    u16,\n    u32,\n    f32,\n    f64\n]])\n")),(0,a.kt)("h3",{id:"number-literals"},"Number literals"),(0,a.kt)("p",null,"Number literals function like a type literals except their stored size is base on the number supplied. You still need to supply the value as an argument for performance reasons, and the supplied number can override the literal (also for performance reasons); there is NO benefit to using number literals like that intentionally, use a type literal instead."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"local ser, des = SerDesmond.Compile([[\n    array(1, 2)\n]])\n\nlocal result = des(ser(1, 2))\n-- result == { [1] = 1, [2] = 2}\n")),(0,a.kt)("h3",{id:"string-literals"},"String literals"),(0,a.kt)("p",null,"String literals function like number literals, however, the value passed in is ignored and the compiled value is used. The treatment of arguments may be made consistent between number/string literals in the future."),(0,a.kt)("p",null,"The behavior of ignoring the argument is not intended to be leveraged."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local ser, des = SerDesmond.Compile([[ "test" ]])\n\nlocal result = des(ser(1))\n-- result == "test"\n')),(0,a.kt)("h3",{id:"strings"},"Strings"),(0,a.kt)("p",null,"Strings are just like string literals except any string can take its value."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local ser, des = SerDesmond.Compile([[ array(string, string) ]])\n\nlocal result = des(ser({"one", "three"}))\n-- result == {"one", "three"}\n')),(0,a.kt)("h3",{id:"arrays"},"Arrays"),(0,a.kt)("p",null,"Arrays are a fixed-length ordered list of constructs. You cannot use less or more than the list of supplied constructs."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local ser, des = SerDesmond.Compile([[\n    array(\n        array("Yep", i8),\n        array(f32, f32)\n    )\n]])\n\nlocal result = des(ser({\n    { "Yep", 1 },\n    { 3.14, -3.14 }\n}))\n')),(0,a.kt)("h3",{id:"periodic-arrays"},"Periodic arrays"),(0,a.kt)("p",null,"Sometimes you just have a list of things that you want to chuck in a single array... over and over. You can describe that with periodic arrays, who's contents will be just like an array but it can repeat any number of times."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local ser, des = SerDesmond.Compile([[\n    periodic_array(\n        string, i8\n    )\n]])\n\nlocal result = des(ser({\n    "thing1", 1\n    "thing2", 2\n}))\n-- result == {\n--   [1] = "thing1",\n--   [2] = 1,\n--   [3] = "thing2,\n--   [4] = 2,\n-- }\n')),(0,a.kt)("h3",{id:"enums"},"Enums"),(0,a.kt)("p",null,"An enum is a list of strings that will be stored as numbers instead. You can use each string any number of times. The deserialized order is not equivalent to the order they are passed in."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local ser, des = SerDesmond.Compile([[\n    enum(\n        "test1", "test2, "test3\n    )\n]])\n\nlocal buf = ser({"test1", "test1", "test3"})\n-- buf len == 3, contains 0x1, 0x1, 0x3 in any order\nlocal result = des(buf)\n-- result == {"test1", "test1", "test3"}\n-- but in any order!\n')),(0,a.kt)("h3",{id:"maps"},"Maps"),(0,a.kt)("p",null,"Describes a table with an indexer of one type and a value of another type"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"local ser, des = SerDesmond.Compile([[\n    map(\n        string: i8\n    )\n]])\n\nlocal result = des(ser( {thing1 = 1, thing2 = 2} ))\n-- result == {thing1 = 1, thing2 = 2}\n")),(0,a.kt)("h3",{id:"structs"},"Structs"),(0,a.kt)("p",null,"Maps indexers that are type literals to a construct. Can use both string and number literals as indexers."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local ser, des = SerDesmond.Compile([[\n    struct(\n        "thing1": i8,\n        "thing2": f64\n    )\n]])\n\nlocal result = des(ser( {thing1 = 1, thing2 = 3.14} ))\n')),(0,a.kt)("h3",{id:"vector3"},"Vector3"),(0,a.kt)("p",null,"A simple Vector3 :~) Unlike most libraries each axis can be restricted to its own primitive."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"local ser, des = SerDesmond.Compile([[ vector3(i8, i32, i8)]])\n")),(0,a.kt)("h3",{id:"comments"},"Comments"),(0,a.kt)("p",null,"We support comments with the ",(0,a.kt)("inlineCode",{parentName:"p"},"#")," symbol."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local ser, des = SerDesmond.Compile([[\n    # This is my fancy thing\n    struct # It is so cool\n    (\n        "thing1": # I just love it\n        f64\n    )\n]])\n')))}d.isMDXComponent=!0}}]);